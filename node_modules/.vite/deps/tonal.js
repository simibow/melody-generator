import {
  __export
} from "./chunk-P2LSHJDD.js";

// node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
var SIZES = [0, 2, 4, 5, 7, 9, 11];
var chroma = ({ step, alt }) => (SIZES[step] + alt + 120) % 12;
var height = ({ step, alt, oct, dir = 1 }) => dir * (SIZES[step] + alt + 12 * (oct === void 0 ? -100 : oct));
var midi = (pitch2) => {
  const h = height(pitch2);
  return pitch2.oct !== void 0 && h >= -12 && h <= 115 ? h + 12 : null;
};
function isPitch(pitch2) {
  return pitch2 !== null && typeof pitch2 === "object" && "step" in pitch2 && typeof pitch2.step === "number" && "alt" in pitch2 && typeof pitch2.alt === "number" && !isNaN(pitch2.step) && !isNaN(pitch2.alt) ? true : false;
}
var FIFTHS = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS = FIFTHS.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates(pitch2) {
  const { step, alt, oct, dir = 1 } = pitch2;
  const f = FIFTHS[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];
function pitch(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS[unaltered(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS[step];
  return { step, alt, oct, dir };
}
function unaltered(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX = new RegExp(
  "^" + INTERVAL_TONAL_REGEX + "|" + INTERVAL_SHORTHAND_REGEX + "$"
);
function tokenizeInterval(str) {
  const m = REGEX.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache = {};
function interval(src) {
  return typeof src === "string" ? cache[src] || (cache[src] = parse(src)) : isPitch(src) ? interval(pitchName(src)) : isNamedPitch(src) ? interval(src.name) : NoInterval;
}
var SIZES2 = [0, 2, 4, 5, 7, 9, 11];
var TYPES = "PMMPPMM";
function parse(str) {
  const tokens = tokenizeInterval(str);
  if (tokens[0] === "") {
    return NoInterval;
  }
  const num3 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num3) - 1) % 7;
  const t = TYPES[step];
  if (t === "M" && q === "P") {
    return NoInterval;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name3 = "" + num3 + q;
  const dir = num3 < 0 ? -1 : 1;
  const simple = num3 === 8 || num3 === -8 ? num3 : dir * (step + 1);
  const alt = qToAlt(type, q);
  const oct = Math.floor((Math.abs(num3) - 1) / 7);
  const semitones2 = dir * (SIZES2[step] + alt + 12 * oct);
  const chroma5 = (dir * (SIZES2[step] + alt) % 12 + 12) % 12;
  const coord = coordinates({ step, alt, oct, dir });
  return {
    empty: false,
    name: name3,
    num: num3,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma5,
    coord,
    oct
  };
}
function coordToInterval(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval(pitch(ivl));
}
function qToAlt(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num3 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES[step] === "M" ? "majorable" : "perfectable";
  const name3 = d + num3 + altToQ(type, alt);
  return name3;
}
function altToQ(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr("A", alt);
  } else {
    return fillStr("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/pitch-note/dist/index.mjs
var fillStr2 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoNote = Object.freeze({
  empty: true,
  name: "",
  letter: "",
  acc: "",
  pc: "",
  step: NaN,
  alt: NaN,
  chroma: NaN,
  height: NaN,
  coord: [],
  midi: null,
  freq: null
});
var cache2 = /* @__PURE__ */ new Map();
var stepToLetter = (step) => "CDEFGAB".charAt(step);
var altToAcc = (alt) => alt < 0 ? fillStr2("b", -alt) : fillStr2("#", alt);
var accToAlt = (acc) => acc[0] === "b" ? -acc.length : acc.length;
function note(src) {
  const stringSrc = JSON.stringify(src);
  const cached = cache2.get(stringSrc);
  if (cached) {
    return cached;
  }
  const value2 = typeof src === "string" ? parse2(src) : isPitch(src) ? note(pitchName2(src)) : isNamedPitch(src) ? note(src.name) : NoNote;
  cache2.set(stringSrc, value2);
  return value2;
}
var REGEX2 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenizeNote(str) {
  const m = REGEX2.exec(str);
  return m ? [m[1].toUpperCase(), m[2].replace(/x/g, "##"), m[3], m[4]] : ["", "", "", ""];
}
function coordToNote(noteCoord) {
  return note(pitch(noteCoord));
}
var mod = (n, m) => (n % m + m) % m;
var SEMI = [0, 2, 4, 5, 7, 9, 11];
function parse2(noteName) {
  const tokens = tokenizeNote(noteName);
  if (tokens[0] === "" || tokens[3] !== "") {
    return NoNote;
  }
  const letter = tokens[0];
  const acc = tokens[1];
  const octStr = tokens[2];
  const step = (letter.charCodeAt(0) + 3) % 7;
  const alt = accToAlt(acc);
  const oct = octStr.length ? +octStr : void 0;
  const coord = coordinates({ step, alt, oct });
  const name3 = letter + acc + octStr;
  const pc = letter + acc;
  const chroma5 = (SEMI[step] + alt + 120) % 12;
  const height2 = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);
  const midi3 = height2 >= 0 && height2 <= 127 ? height2 : null;
  const freq2 = oct === void 0 ? null : Math.pow(2, (height2 - 69) / 12) * 440;
  return {
    empty: false,
    acc,
    alt,
    chroma: chroma5,
    coord,
    freq: freq2,
    height: height2,
    letter,
    midi: midi3,
    name: name3,
    oct,
    pc,
    step
  };
}
function pitchName2(props) {
  const { step, alt, oct } = props;
  const letter = stepToLetter(step);
  if (!letter) {
    return "";
  }
  const pc = letter + altToAcc(alt);
  return oct || oct === 0 ? pc + oct : pc;
}

// node_modules/@tonaljs/pitch-distance/dist/index.mjs
function transpose(noteName, intervalName) {
  const note2 = note(noteName);
  const intervalCoord = Array.isArray(intervalName) ? intervalName : interval(intervalName).coord;
  if (note2.empty || !intervalCoord || intervalCoord.length < 2) {
    return "";
  }
  const noteCoord = note2.coord;
  const tr2 = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];
  return coordToNote(tr2).name;
}
function tonicIntervalsTransposer(intervals2, tonic) {
  const len = intervals2.length;
  return (normalized) => {
    if (!tonic)
      return "";
    const index4 = normalized < 0 ? (len - -normalized % len) % len : normalized % len;
    const octaves = Math.floor(normalized / len);
    const root = transpose(tonic, [0, octaves]);
    return transpose(root, intervals2[index4]);
  };
}
function distance(fromNote, toNote) {
  const from = note(fromNote);
  const to = note(toNote);
  if (from.empty || to.empty) {
    return "";
  }
  const fcoord = from.coord;
  const tcoord = to.coord;
  const fifths = tcoord[0] - fcoord[0];
  const octs = fcoord.length === 2 && tcoord.length === 2 ? tcoord[1] - fcoord[1] : -Math.floor(fifths * 7 / 12);
  const forceDescending = to.height === from.height && to.midi !== null && from.midi !== null && from.step > to.step;
  return coordToInterval([fifths, octs], forceDescending).name;
}

// node_modules/@tonaljs/abc-notation/dist/index.mjs
var fillStr3 = (character, times) => Array(times + 1).join(character);
var REGEX3 = /^(_{1,}|=|\^{1,}|)([abcdefgABCDEFG])([,']*)$/;
function tokenize(str) {
  const m = REGEX3.exec(str);
  if (!m) {
    return ["", "", ""];
  }
  return [m[1], m[2], m[3]];
}
function abcToScientificNotation(str) {
  const [acc, letter, oct] = tokenize(str);
  if (letter === "") {
    return "";
  }
  let o = 4;
  for (let i = 0; i < oct.length; i++) {
    o += oct.charAt(i) === "," ? -1 : 1;
  }
  const a = acc[0] === "_" ? acc.replace(/_/g, "b") : acc[0] === "^" ? acc.replace(/\^/g, "#") : "";
  return letter.charCodeAt(0) > 96 ? letter.toUpperCase() + a + (o + 1) : letter + a + o;
}
function scientificToAbcNotation(str) {
  const n = note(str);
  if (n.empty || !n.oct && n.oct !== 0) {
    return "";
  }
  const { letter, acc, oct } = n;
  const a = acc[0] === "b" ? acc.replace(/b/g, "_") : acc.replace(/#/g, "^");
  const l = oct > 4 ? letter.toLowerCase() : letter;
  const o = oct === 5 ? "" : oct > 4 ? fillStr3("'", oct - 5) : fillStr3(",", 4 - oct);
  return a + l + o;
}
function transpose2(note2, interval2) {
  return scientificToAbcNotation(transpose(abcToScientificNotation(note2), interval2));
}
function distance2(from, to) {
  return distance(abcToScientificNotation(from), abcToScientificNotation(to));
}
var abc_notation_default = {
  abcToScientificNotation,
  scientificToAbcNotation,
  tokenize,
  transpose: transpose2,
  distance: distance2
};

// node_modules/@tonaljs/array/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  compact: () => compact,
  permutations: () => permutations,
  range: () => range,
  rotate: () => rotate,
  shuffle: () => shuffle,
  sortedNoteNames: () => sortedNoteNames,
  sortedUniqNoteNames: () => sortedUniqNoteNames
});
function ascR(b, n) {
  const a = [];
  for (; n--; a[n] = n + b)
    ;
  return a;
}
function descR(b, n) {
  const a = [];
  for (; n--; a[n] = b - n)
    ;
  return a;
}
function range(from, to) {
  return from < to ? ascR(from, to - from + 1) : descR(from, from - to + 1);
}
function rotate(times, arr) {
  const len = arr.length;
  const n = (times % len + len) % len;
  return arr.slice(n, len).concat(arr.slice(0, n));
}
function compact(arr) {
  return arr.filter((n) => n === 0 || n);
}
function sortedNoteNames(notes4) {
  const valid = notes4.map((n) => note(n)).filter((n) => !n.empty);
  return valid.sort((a, b) => a.height - b.height).map((n) => n.name);
}
function sortedUniqNoteNames(arr) {
  return sortedNoteNames(arr).filter((n, i, a) => i === 0 || n !== a[i - 1]);
}
function shuffle(arr, rnd = Math.random) {
  let i;
  let t;
  let m = arr.length;
  while (m) {
    i = Math.floor(rnd() * m--);
    t = arr[m];
    arr[m] = arr[i];
    arr[i] = t;
  }
  return arr;
}
function permutations(arr) {
  if (arr.length === 0) {
    return [[]];
  }
  return permutations(arr.slice(1)).reduce((acc, perm) => {
    return acc.concat(
      arr.map((e, pos) => {
        const newPerm = perm.slice();
        newPerm.splice(pos, 0, arr[0]);
        return newPerm;
      })
    );
  }, []);
}

// node_modules/@tonaljs/core/dist/index.mjs
var dist_exports2 = {};
__export(dist_exports2, {
  accToAlt: () => accToAlt,
  altToAcc: () => altToAcc,
  chroma: () => chroma,
  coordToInterval: () => coordToInterval,
  coordToNote: () => coordToNote,
  coordinates: () => coordinates,
  deprecate: () => deprecate,
  distance: () => distance,
  fillStr: () => fillStr4,
  height: () => height,
  interval: () => interval,
  isNamed: () => isNamed,
  isNamedPitch: () => isNamedPitch,
  isPitch: () => isPitch,
  midi: () => midi,
  note: () => note,
  pitch: () => pitch,
  stepToLetter: () => stepToLetter,
  tokenizeInterval: () => tokenizeInterval,
  tokenizeNote: () => tokenizeNote,
  tonicIntervalsTransposer: () => tonicIntervalsTransposer,
  transpose: () => transpose
});
var fillStr4 = (s, n) => Array(Math.abs(n) + 1).join(s);
function deprecate(original, alternative, fn) {
  return function(...args) {
    console.warn(`${original} is deprecated. Use ${alternative}.`);
    return fn.apply(this, args);
  };
}
var isNamed = deprecate("isNamed", "isNamedPitch", isNamedPitch);

// node_modules/@tonaljs/collection/dist/index.mjs
function ascR2(b, n) {
  const a = [];
  for (; n--; a[n] = n + b)
    ;
  return a;
}
function descR2(b, n) {
  const a = [];
  for (; n--; a[n] = b - n)
    ;
  return a;
}
function range2(from, to) {
  return from < to ? ascR2(from, to - from + 1) : descR2(from, from - to + 1);
}
function rotate2(times, arr) {
  const len = arr.length;
  const n = (times % len + len) % len;
  return arr.slice(n, len).concat(arr.slice(0, n));
}
function compact2(arr) {
  return arr.filter((n) => n === 0 || n);
}
function shuffle2(arr, rnd = Math.random) {
  let i;
  let t;
  let m = arr.length;
  while (m) {
    i = Math.floor(rnd() * m--);
    t = arr[m];
    arr[m] = arr[i];
    arr[i] = t;
  }
  return arr;
}
function permutations2(arr) {
  if (arr.length === 0) {
    return [[]];
  }
  return permutations2(arr.slice(1)).reduce((acc, perm) => {
    return acc.concat(
      arr.map((e, pos) => {
        const newPerm = perm.slice();
        newPerm.splice(pos, 0, arr[0]);
        return newPerm;
      })
    );
  }, []);
}
var collection_default = {
  compact: compact2,
  permutations: permutations2,
  range: range2,
  rotate: rotate2,
  shuffle: shuffle2
};

// node_modules/@tonaljs/pcset/dist/index.mjs
var EmptyPcset = {
  empty: true,
  name: "",
  setNum: 0,
  chroma: "000000000000",
  normalized: "000000000000",
  intervals: []
};
var setNumToChroma = (num22) => Number(num22).toString(2).padStart(12, "0");
var chromaToNumber = (chroma22) => parseInt(chroma22, 2);
var REGEX4 = /^[01]{12}$/;
function isChroma(set) {
  return REGEX4.test(set);
}
var isPcsetNum = (set) => typeof set === "number" && set >= 0 && set <= 4095;
var isPcset = (set) => set && isChroma(set.chroma);
var cache3 = { [EmptyPcset.chroma]: EmptyPcset };
function get(src) {
  const chroma22 = isChroma(src) ? src : isPcsetNum(src) ? setNumToChroma(src) : Array.isArray(src) ? listToChroma(src) : isPcset(src) ? src.chroma : EmptyPcset.chroma;
  return cache3[chroma22] = cache3[chroma22] || chromaToPcset(chroma22);
}
var pcset = deprecate("Pcset.pcset", "Pcset.get", get);
var chroma2 = (set) => get(set).chroma;
var intervals = (set) => get(set).intervals;
var num = (set) => get(set).setNum;
var IVLS = [
  "1P",
  "2m",
  "2M",
  "3m",
  "3M",
  "4P",
  "5d",
  "5P",
  "6m",
  "6M",
  "7m",
  "7M"
];
function chromaToIntervals(chroma22) {
  const intervals2 = [];
  for (let i = 0; i < 12; i++) {
    if (chroma22.charAt(i) === "1")
      intervals2.push(IVLS[i]);
  }
  return intervals2;
}
function notes(set) {
  return get(set).intervals.map((ivl) => transpose("C", ivl));
}
function chromas() {
  return range2(2048, 4095).map(setNumToChroma);
}
function modes(set, normalize = true) {
  const pcs = get(set);
  const binary = pcs.chroma.split("");
  return compact2(
    binary.map((_, i) => {
      const r = rotate2(i, binary);
      return normalize && r[0] === "0" ? null : r.join("");
    })
  );
}
function isEqual(s1, s2) {
  return get(s1).setNum === get(s2).setNum;
}
function isSubsetOf(set) {
  const s = get(set).setNum;
  return (notes22) => {
    const o = get(notes22).setNum;
    return s && s !== o && (o & s) === o;
  };
}
function isSupersetOf(set) {
  const s = get(set).setNum;
  return (notes22) => {
    const o = get(notes22).setNum;
    return s && s !== o && (o | s) === o;
  };
}
function isNoteIncludedIn(set) {
  const s = get(set);
  return (noteName) => {
    const n = note(noteName);
    return s && !n.empty && s.chroma.charAt(n.chroma) === "1";
  };
}
function filter(set) {
  const isIncluded = isNoteIncludedIn(set);
  return (notes22) => {
    return notes22.filter(isIncluded);
  };
}
var pcset_default = {
  get,
  chroma: chroma2,
  num,
  intervals,
  chromas,
  isSupersetOf,
  isSubsetOf,
  isNoteIncludedIn,
  isEqual,
  filter,
  modes,
  notes,
  // deprecated
  pcset
};
function chromaRotations(chroma22) {
  const binary = chroma22.split("");
  return binary.map((_, i) => rotate2(i, binary).join(""));
}
function chromaToPcset(chroma22) {
  const setNum = chromaToNumber(chroma22);
  const normalizedNum = chromaRotations(chroma22).map(chromaToNumber).filter((n) => n >= 2048).sort()[0];
  const normalized = setNumToChroma(normalizedNum);
  const intervals2 = chromaToIntervals(chroma22);
  return {
    empty: false,
    name: "",
    setNum,
    chroma: chroma22,
    normalized,
    intervals: intervals2
  };
}
function listToChroma(set) {
  if (set.length === 0) {
    return EmptyPcset.chroma;
  }
  let pitch2;
  const binary = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let i = 0; i < set.length; i++) {
    pitch2 = note(set[i]);
    if (pitch2.empty)
      pitch2 = interval(set[i]);
    if (!pitch2.empty)
      binary[pitch2.chroma] = 1;
  }
  return binary.join("");
}

// node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default = CHORDS;
var NoChordType = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary = [];
var index = {};
function get2(type) {
  return index[type] || NoChordType;
}
var chordType = deprecate("ChordType.chordType", "ChordType.get", get2);
function names() {
  return dictionary.map((chord2) => chord2.name).filter((x) => x);
}
function symbols() {
  return dictionary.map((chord2) => chord2.aliases[0]).filter((x) => x);
}
function keys() {
  return Object.keys(index);
}
function all() {
  return dictionary.slice();
}
var entries = deprecate("ChordType.entries", "ChordType.all", all);
function removeAll() {
  dictionary = [];
  index = {};
}
function add(intervals2, aliases, fullName) {
  const quality2 = getQuality(intervals2);
  const chord2 = {
    ...get(intervals2),
    name: fullName || "",
    quality: quality2,
    intervals: intervals2,
    aliases
  };
  dictionary.push(chord2);
  if (chord2.name) {
    index[chord2.name] = chord2;
  }
  index[chord2.setNum] = chord2;
  index[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias(chord2, alias));
}
function addAlias(chord2, alias) {
  index[alias] = chord2;
}
function getQuality(intervals2) {
  const has = (interval2) => intervals2.indexOf(interval2) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default.forEach(
  ([ivls, fullName, names22]) => add(ivls.split(" "), names22.split(" "), fullName)
);
dictionary.sort((a, b) => a.setNum - b.setNum);
var chord_type_default = {
  names,
  symbols,
  get: get2,
  all,
  add,
  removeAll,
  keys,
  // deprecated
  entries,
  chordType
};

// node_modules/@tonaljs/chord-detect/dist/index.mjs
var namedSet = (notes4) => {
  const pcToName = notes4.reduce((record, n) => {
    const chroma5 = note(n).chroma;
    if (chroma5 !== void 0) {
      record[chroma5] = record[chroma5] || note(n).name;
    }
    return record;
  }, {});
  return (chroma5) => pcToName[chroma5];
};
function detect(source, options = {}) {
  const notes4 = source.map((n) => note(n).pc).filter((x) => x);
  if (note.length === 0) {
    return [];
  }
  const found = findMatches(notes4, 1, options);
  return found.filter((chord2) => chord2.weight).sort((a, b) => b.weight - a.weight).map((chord2) => chord2.name);
}
var BITMASK = {
  // 3m 000100000000
  // 3M 000010000000
  anyThirds: 384,
  // 5P 000000010000
  perfectFifth: 16,
  // 5d 000000100000
  // 5A 000000001000
  nonPerfectFifths: 40,
  anySeventh: 3
};
var testChromaNumber = (bitmask) => (chromaNumber) => Boolean(chromaNumber & bitmask);
var hasAnyThird = testChromaNumber(BITMASK.anyThirds);
var hasPerfectFifth = testChromaNumber(BITMASK.perfectFifth);
var hasAnySeventh = testChromaNumber(BITMASK.anySeventh);
var hasNonPerfectFifth = testChromaNumber(BITMASK.nonPerfectFifths);
function hasAnyThirdAndPerfectFifthAndAnySeventh(chordType2) {
  const chromaNumber = parseInt(chordType2.chroma, 2);
  return hasAnyThird(chromaNumber) && hasPerfectFifth(chromaNumber) && hasAnySeventh(chromaNumber);
}
function withPerfectFifth(chroma5) {
  const chromaNumber = parseInt(chroma5, 2);
  return hasNonPerfectFifth(chromaNumber) ? chroma5 : (chromaNumber | 16).toString(2);
}
function findMatches(notes4, weight, options) {
  const tonic = notes4[0];
  const tonicChroma = note(tonic).chroma;
  const noteName = namedSet(notes4);
  const allModes = modes(notes4, false);
  const found = [];
  allModes.forEach((mode2, index4) => {
    const modeWithPerfectFifth = options.assumePerfectFifth && withPerfectFifth(mode2);
    const chordTypes = all().filter((chordType2) => {
      if (options.assumePerfectFifth && hasAnyThirdAndPerfectFifthAndAnySeventh(chordType2)) {
        return chordType2.chroma === modeWithPerfectFifth;
      }
      return chordType2.chroma === mode2;
    });
    chordTypes.forEach((chordType2) => {
      const chordName = chordType2.aliases[0];
      const baseNote = noteName(index4);
      const isInversion = index4 !== tonicChroma;
      if (isInversion) {
        found.push({
          weight: 0.5 * weight,
          name: `${baseNote}${chordName}/${tonic}`
        });
      } else {
        found.push({ weight: 1 * weight, name: `${baseNote}${chordName}` });
      }
    });
  });
  return found;
}

// node_modules/@tonaljs/interval/dist/index.mjs
function names2() {
  return "1P 2M 3M 4P 5P 6m 7m".split(" ");
}
var get3 = interval;
var name = (name22) => interval(name22).name;
var semitones = (name22) => interval(name22).semitones;
var quality = (name22) => interval(name22).q;
var num2 = (name22) => interval(name22).num;
function simplify(name22) {
  const i = interval(name22);
  return i.empty ? "" : i.simple + i.q;
}
function invert(name22) {
  const i = interval(name22);
  if (i.empty) {
    return "";
  }
  const step = (7 - i.step) % 7;
  const alt = i.type === "perfectable" ? -i.alt : -(i.alt + 1);
  return interval({ step, alt, oct: i.oct, dir: i.dir }).name;
}
var IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];
var IQ = "P m M m M P d P m M m M".split(" ");
function fromSemitones(semitones2) {
  const d = semitones2 < 0 ? -1 : 1;
  const n = Math.abs(semitones2);
  const c = n % 12;
  const o = Math.floor(n / 12);
  return d * (IN[c] + 7 * o) + IQ[c];
}
var distance3 = distance;
var add2 = combinator((a, b) => [a[0] + b[0], a[1] + b[1]]);
var addTo = (interval2) => (other) => add2(interval2, other);
var subtract = combinator((a, b) => [a[0] - b[0], a[1] - b[1]]);
function transposeFifths(interval2, fifths) {
  const ivl = get3(interval2);
  if (ivl.empty)
    return "";
  const [nFifths, nOcts, dir] = ivl.coord;
  return coordToInterval([nFifths + fifths, nOcts, dir]).name;
}
var interval_default = {
  names: names2,
  get: get3,
  name,
  num: num2,
  semitones,
  quality,
  fromSemitones,
  distance: distance3,
  invert,
  simplify,
  add: add2,
  addTo,
  subtract,
  transposeFifths
};
function combinator(fn) {
  return (a, b) => {
    const coordA = interval(a).coord;
    const coordB = interval(b).coord;
    if (coordA && coordB) {
      const coord = fn(coordA, coordB);
      return coordToInterval(coord).name;
    }
  };
}

// node_modules/@tonaljs/scale-type/dist/index.mjs
var SCALES = [
  // Basic scales
  ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
  ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
  ["1P 2M 3m 4P 5P 6m 7m", "minor", "aeolian"],
  // Jazz common scales
  ["1P 2M 3m 3M 5P 6M", "major blues"],
  ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
  ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
  ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
  ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
  ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
  // Modes
  ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
  ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
  ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
  ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
  ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
  // 5-note scales
  ["1P 3M 4P 5P 7M", "ionian pentatonic"],
  ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
  ["1P 2M 4P 5P 6M", "ritusen"],
  ["1P 2M 4P 5P 7m", "egyptian"],
  ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
  ["1P 3m 4P 5P 6m", "vietnamese 1"],
  ["1P 2m 3m 5P 6m", "pelog"],
  ["1P 2m 4P 5P 6m", "kumoijoshi"],
  ["1P 2M 3m 5P 6m", "hirajoshi"],
  ["1P 2m 4P 5d 7m", "iwato"],
  ["1P 2m 4P 5P 7m", "in-sen"],
  ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
  ["1P 3m 4P 6m 7m", "malkos raga"],
  ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
  ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
  ["1P 3m 4P 5P 6M", "minor six pentatonic"],
  ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
  ["1P 2M 3M 5P 6m", "flat six pentatonic"],
  ["1P 2m 3M 5P 6M", "scriabin"],
  ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
  ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
  ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
  ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
  ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
  // 6-note scales
  ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
  ["1P 2A 3M 5P 5A 7M", "augmented"],
  ["1P 2M 4P 5P 6M 7m", "piongio"],
  ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
  ["1P 2M 3M 4A 6M 7m", "prometheus"],
  ["1P 2m 3M 5d 6m 7m", "mystery #1"],
  ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
  ["1P 2M 3M 4A 5A 6A", "whole tone", "messiaen's mode #1"],
  ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
  // 7-note scales
  ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
  ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
  [
    "1P 2m 2A 3M 4A 6m 7m",
    "altered",
    "super locrian",
    "diminished whole tone",
    "pomeroy"
  ],
  ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
  [
    "1P 2M 3M 4P 5P 6m 7m",
    "mixolydian b6",
    "melodic minor fifth mode",
    "hindu"
  ],
  ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
  ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
  [
    "1P 2m 3m 4P 5P 6M 7m",
    "dorian b2",
    "phrygian #6",
    "melodic minor second mode"
  ],
  [
    "1P 2m 3m 4d 5d 6m 7d",
    "ultralocrian",
    "superlocrian bb7",
    "superlocrian diminished"
  ],
  ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
  ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
  // Source https://en.wikipedia.org/wiki/Ukrainian_Dorian_scale
  [
    "1P 2M 3m 4A 5P 6M 7m",
    "dorian #4",
    "ukrainian dorian",
    "romanian minor",
    "altered dorian"
  ],
  ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
  ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
  ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
  ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
  ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
  ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
  ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
  ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
  ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
  ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
  ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
  ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
  ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
  ["1P 2m 3M 4P 5d 6m 7M", "persian"],
  ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
  [
    "1P 2M 3M 4P 5A 6M 7M",
    "major augmented",
    "major #5",
    "ionian augmented",
    "ionian #5"
  ],
  ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
  // 8-note scales
  ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
  ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
  ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
  ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
  ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
  ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
  ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
  ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
  ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
  [
    "1P 2m 3m 3M 4A 5P 6M 7m",
    "half-whole diminished",
    "dominant diminished",
    "messiaen's mode #2"
  ],
  ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
  ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
  // 9-note scales
  ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
  ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
  // 10-note scales
  ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
  // 12-note scales
  ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
];
var data_default2 = SCALES;
var NoScaleType = {
  ...EmptyPcset,
  intervals: [],
  aliases: []
};
var dictionary2 = [];
var index2 = {};
function names3() {
  return dictionary2.map((scale2) => scale2.name);
}
function get4(type) {
  return index2[type] || NoScaleType;
}
var scaleType = deprecate(
  "ScaleDictionary.scaleType",
  "ScaleType.get",
  get4
);
function all2() {
  return dictionary2.slice();
}
var entries2 = deprecate(
  "ScaleDictionary.entries",
  "ScaleType.all",
  all2
);
function keys2() {
  return Object.keys(index2);
}
function removeAll2() {
  dictionary2 = [];
  index2 = {};
}
function add3(intervals2, name3, aliases = []) {
  const scale2 = { ...get(intervals2), name: name3, intervals: intervals2, aliases };
  dictionary2.push(scale2);
  index2[scale2.name] = scale2;
  index2[scale2.setNum] = scale2;
  index2[scale2.chroma] = scale2;
  scale2.aliases.forEach((alias) => addAlias2(scale2, alias));
  return scale2;
}
function addAlias2(scale2, alias) {
  index2[alias] = scale2;
}
data_default2.forEach(
  ([ivls, name3, ...aliases]) => add3(ivls.split(" "), name3, aliases)
);
var scale_type_default = {
  names: names3,
  get: get4,
  all: all2,
  add: add3,
  removeAll: removeAll2,
  keys: keys2,
  // deprecated
  entries: entries2,
  scaleType
};

// node_modules/@tonaljs/chord/dist/index.mjs
var NoChord = {
  empty: true,
  name: "",
  symbol: "",
  root: "",
  bass: "",
  rootDegree: 0,
  type: "",
  tonic: null,
  setNum: NaN,
  quality: "Unknown",
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function tokenize2(name3) {
  const [letter, acc, oct, type] = tokenizeNote(name3);
  if (letter === "") {
    return tokenizeBass("", name3);
  } else if (letter === "A" && type === "ug") {
    return tokenizeBass("", "aug");
  } else {
    return tokenizeBass(letter + acc, oct + type);
  }
}
function tokenizeBass(note2, chord2) {
  const split = chord2.split("/");
  if (split.length === 1) {
    return [note2, split[0], ""];
  }
  const [letter, acc, oct, type] = tokenizeNote(split[1]);
  if (letter !== "" && oct === "" && type === "") {
    return [note2, split[0], letter + acc];
  } else {
    return [note2, chord2, ""];
  }
}
function get5(src) {
  if (Array.isArray(src)) {
    return getChord(src[1] || "", src[0], src[2]);
  } else if (src === "") {
    return NoChord;
  } else {
    const [tonic, type, bass] = tokenize2(src);
    const chord2 = getChord(type, tonic, bass);
    return chord2.empty ? getChord(src) : chord2;
  }
}
function getChord(typeName, optionalTonic, optionalBass) {
  const type = get2(typeName);
  const tonic = note(optionalTonic || "");
  const bass = note(optionalBass || "");
  if (type.empty || optionalTonic && tonic.empty || optionalBass && bass.empty) {
    return NoChord;
  }
  const bassInterval = distance(tonic.pc, bass.pc);
  const bassIndex = type.intervals.indexOf(bassInterval);
  const hasRoot = bassIndex >= 0;
  const root = hasRoot ? bass : note("");
  const rootDegree = bassIndex === -1 ? NaN : bassIndex + 1;
  const hasBass = bass.pc && bass.pc !== tonic.pc;
  const intervals2 = Array.from(type.intervals);
  if (hasRoot) {
    for (let i = 1; i < rootDegree; i++) {
      const num3 = intervals2[0][0];
      const quality2 = intervals2[0][1];
      const newNum = parseInt(num3, 10) + 7;
      intervals2.push(`${newNum}${quality2}`);
      intervals2.shift();
    }
  } else if (hasBass) {
    const ivl = subtract(distance(tonic.pc, bass.pc), "8P");
    if (ivl)
      intervals2.unshift(ivl);
  }
  const notes22 = tonic.empty ? [] : intervals2.map((i) => transpose(tonic.pc, i));
  typeName = type.aliases.indexOf(typeName) !== -1 ? typeName : type.aliases[0];
  const symbol = `${tonic.empty ? "" : tonic.pc}${typeName}${hasRoot && rootDegree > 1 ? "/" + root.pc : hasBass ? "/" + bass.pc : ""}`;
  const name3 = `${optionalTonic ? tonic.pc + " " : ""}${type.name}${hasRoot && rootDegree > 1 ? " over " + root.pc : hasBass ? " over " + bass.pc : ""}`;
  return {
    ...type,
    name: name3,
    symbol,
    tonic: tonic.pc,
    type: type.name,
    root: root.pc,
    bass: hasBass ? bass.pc : "",
    intervals: intervals2,
    rootDegree,
    notes: notes22
  };
}
var chord = get5;
function transpose3(chordName, interval2) {
  const [tonic, type, bass] = tokenize2(chordName);
  if (!tonic) {
    return chordName;
  }
  const tr2 = transpose(bass, interval2);
  const slash = tr2 ? "/" + tr2 : "";
  return transpose(tonic, interval2) + type + slash;
}
function chordScales(name3) {
  const s = get5(name3);
  const isChordIncluded = isSupersetOf(s.chroma);
  return all2().filter((scale2) => isChordIncluded(scale2.chroma)).map((scale2) => scale2.name);
}
function extended(chordName) {
  const s = get5(chordName);
  const isSuperset = isSupersetOf(s.chroma);
  return all().filter((chord2) => isSuperset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
function reduced(chordName) {
  const s = get5(chordName);
  const isSubset = isSubsetOf(s.chroma);
  return all().filter((chord2) => isSubset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
function notes2(chordName, tonic) {
  const chord2 = get5(chordName);
  const note2 = tonic || chord2.tonic;
  if (!note2 || chord2.empty)
    return [];
  return chord2.intervals.map((ivl) => transpose(note2, ivl));
}
function degrees(chordName, tonic) {
  const chord2 = get5(chordName);
  const note2 = tonic || chord2.tonic;
  const transpose22 = tonicIntervalsTransposer(chord2.intervals, note2);
  return (degree) => degree ? transpose22(degree > 0 ? degree - 1 : degree) : "";
}
function steps(chordName, tonic) {
  const chord2 = get5(chordName);
  const note2 = tonic || chord2.tonic;
  return tonicIntervalsTransposer(chord2.intervals, note2);
}
var chord_default = {
  getChord,
  get: get5,
  detect,
  chordScales,
  extended,
  reduced,
  tokenize: tokenize2,
  transpose: transpose3,
  degrees,
  steps,
  notes: notes2,
  chord
};

// node_modules/@tonaljs/duration-value/dist/index.mjs
var DATA = [
  [
    0.125,
    "dl",
    ["large", "duplex longa", "maxima", "octuple", "octuple whole"]
  ],
  [0.25, "l", ["long", "longa"]],
  [0.5, "d", ["double whole", "double", "breve"]],
  [1, "w", ["whole", "semibreve"]],
  [2, "h", ["half", "minim"]],
  [4, "q", ["quarter", "crotchet"]],
  [8, "e", ["eighth", "quaver"]],
  [16, "s", ["sixteenth", "semiquaver"]],
  [32, "t", ["thirty-second", "demisemiquaver"]],
  [64, "sf", ["sixty-fourth", "hemidemisemiquaver"]],
  [128, "h", ["hundred twenty-eighth"]],
  [256, "th", ["two hundred fifty-sixth"]]
];
var data_default3 = DATA;
var VALUES = [];
data_default3.forEach(
  ([denominator, shorthand, names22]) => add4(denominator, shorthand, names22)
);
var NoDuration = {
  empty: true,
  name: "",
  value: 0,
  fraction: [0, 0],
  shorthand: "",
  dots: "",
  names: []
};
function names4() {
  return VALUES.reduce((names22, duration) => {
    duration.names.forEach((name3) => names22.push(name3));
    return names22;
  }, []);
}
function shorthands() {
  return VALUES.map((dur) => dur.shorthand);
}
var REGEX5 = /^([^.]+)(\.*)$/;
function get6(name3) {
  const [_, simple, dots] = REGEX5.exec(name3) || [];
  const base = VALUES.find(
    (dur) => dur.shorthand === simple || dur.names.includes(simple)
  );
  if (!base) {
    return NoDuration;
  }
  const fraction2 = calcDots(base.fraction, dots.length);
  const value2 = fraction2[0] / fraction2[1];
  return { ...base, name: name3, dots, value: value2, fraction: fraction2 };
}
var value = (name3) => get6(name3).value;
var fraction = (name3) => get6(name3).fraction;
var duration_value_default = { names: names4, shorthands, get: get6, value, fraction };
function add4(denominator, shorthand, names22) {
  VALUES.push({
    empty: false,
    dots: "",
    name: "",
    value: 1 / denominator,
    fraction: denominator < 1 ? [1 / denominator, 1] : [1, denominator],
    shorthand,
    names: names22
  });
}
function calcDots(fraction2, dots) {
  const pow = Math.pow(2, dots);
  let numerator = fraction2[0] * pow;
  let denominator = fraction2[1] * pow;
  const base = numerator;
  for (let i = 0; i < dots; i++) {
    numerator += base / Math.pow(2, i + 1);
  }
  while (numerator % 2 === 0 && denominator % 2 === 0) {
    numerator /= 2;
    denominator /= 2;
  }
  return [numerator, denominator];
}

// node_modules/@tonaljs/midi/dist/index.mjs
function isMidi(arg) {
  return +arg >= 0 && +arg <= 127;
}
function toMidi(note2) {
  if (isMidi(note2)) {
    return +note2;
  }
  const n = note(note2);
  return n.empty ? null : n.midi;
}
function midiToFreq(midi3, tuning = 440) {
  return Math.pow(2, (midi3 - 69) / 12) * tuning;
}
var L2 = Math.log(2);
var L440 = Math.log(440);
function freqToMidi(freq2) {
  const v = 12 * (Math.log(freq2) - L440) / L2 + 69;
  return Math.round(v * 100) / 100;
}
var SHARPS = "C C# D D# E F F# G G# A A# B".split(" ");
var FLATS = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
function midiToNoteName(midi3, options = {}) {
  if (isNaN(midi3) || midi3 === -Infinity || midi3 === Infinity)
    return "";
  midi3 = Math.round(midi3);
  const pcs = options.sharps === true ? SHARPS : FLATS;
  const pc = pcs[midi3 % 12];
  if (options.pitchClass) {
    return pc;
  }
  const o = Math.floor(midi3 / 12) - 1;
  return pc + o;
}
function chroma3(midi3) {
  return midi3 % 12;
}
function pcsetFromChroma(chroma22) {
  return chroma22.split("").reduce((pcset22, val, index4) => {
    if (index4 < 12 && val === "1")
      pcset22.push(index4);
    return pcset22;
  }, []);
}
function pcsetFromMidi(midi3) {
  return midi3.map(chroma3).sort((a, b) => a - b).filter((n, i, a) => i === 0 || n !== a[i - 1]);
}
function pcset2(notes4) {
  return Array.isArray(notes4) ? pcsetFromMidi(notes4) : pcsetFromChroma(notes4);
}
function pcsetNearest(notes4) {
  const set = pcset2(notes4);
  return (midi3) => {
    const ch = chroma3(midi3);
    for (let i = 0; i < 12; i++) {
      if (set.includes(ch + i))
        return midi3 + i;
      if (set.includes(ch - i))
        return midi3 - i;
    }
    return void 0;
  };
}
function pcsetSteps(notes4, tonic) {
  const set = pcset2(notes4);
  const len = set.length;
  return (step) => {
    const index4 = step < 0 ? (len - -step % len) % len : step % len;
    const octaves = Math.floor(step / len);
    return set[index4] + octaves * 12 + tonic;
  };
}
function pcsetDegrees(notes4, tonic) {
  const steps3 = pcsetSteps(notes4, tonic);
  return (degree) => {
    if (degree === 0)
      return void 0;
    return steps3(degree > 0 ? degree - 1 : degree);
  };
}
var midi_default = {
  chroma: chroma3,
  freqToMidi,
  isMidi,
  midiToFreq,
  midiToNoteName,
  pcsetNearest,
  pcset: pcset2,
  pcsetDegrees,
  pcsetSteps,
  toMidi
};

// node_modules/@tonaljs/note/dist/index.mjs
var NAMES = ["C", "D", "E", "F", "G", "A", "B"];
var toName = (n) => n.name;
var onlyNotes = (array) => array.map(note).filter((n) => !n.empty);
function names5(array) {
  if (array === void 0) {
    return NAMES.slice();
  } else if (!Array.isArray(array)) {
    return [];
  } else {
    return onlyNotes(array).map(toName);
  }
}
var get7 = note;
var name2 = (note2) => get7(note2).name;
var pitchClass = (note2) => get7(note2).pc;
var accidentals = (note2) => get7(note2).acc;
var octave = (note2) => get7(note2).oct;
var midi2 = (note2) => get7(note2).midi;
var freq = (note2) => get7(note2).freq;
var chroma4 = (note2) => get7(note2).chroma;
function fromMidi(midi22) {
  return midiToNoteName(midi22);
}
function fromFreq(freq2) {
  return midiToNoteName(freqToMidi(freq2));
}
function fromFreqSharps(freq2) {
  return midiToNoteName(freqToMidi(freq2), { sharps: true });
}
function fromMidiSharps(midi22) {
  return midiToNoteName(midi22, { sharps: true });
}
var transpose4 = transpose;
var tr = transpose;
var transposeBy = (interval2) => (note2) => transpose4(note2, interval2);
var trBy = transposeBy;
var transposeFrom = (note2) => (interval2) => transpose4(note2, interval2);
var trFrom = transposeFrom;
function transposeFifths2(noteName, fifths) {
  return transpose4(noteName, [fifths, 0]);
}
var trFifths = transposeFifths2;
function transposeOctaves(noteName, octaves) {
  return transpose4(noteName, [0, octaves]);
}
var ascending = (a, b) => a.height - b.height;
var descending = (a, b) => b.height - a.height;
function sortedNames(notes4, comparator) {
  comparator = comparator || ascending;
  return onlyNotes(notes4).sort(comparator).map(toName);
}
function sortedUniqNames(notes4) {
  return sortedNames(notes4, ascending).filter(
    (n, i, a) => i === 0 || n !== a[i - 1]
  );
}
var simplify2 = (noteName) => {
  const note2 = get7(noteName);
  if (note2.empty) {
    return "";
  }
  return midiToNoteName(note2.midi || note2.chroma, {
    sharps: note2.alt > 0,
    pitchClass: note2.midi === null
  });
};
function enharmonic(noteName, destName) {
  const src = get7(noteName);
  if (src.empty) {
    return "";
  }
  const dest = get7(
    destName || midiToNoteName(src.midi || src.chroma, {
      sharps: src.alt < 0,
      pitchClass: true
    })
  );
  if (dest.empty || dest.chroma !== src.chroma) {
    return "";
  }
  if (src.oct === void 0) {
    return dest.pc;
  }
  const srcChroma = src.chroma - src.alt;
  const destChroma = dest.chroma - dest.alt;
  const destOctOffset = srcChroma > 11 || destChroma < 0 ? -1 : srcChroma < 0 || destChroma > 11 ? 1 : 0;
  const destOct = src.oct + destOctOffset;
  return dest.pc + destOct;
}
var note_default = {
  names: names5,
  get: get7,
  name: name2,
  pitchClass,
  accidentals,
  octave,
  midi: midi2,
  ascending,
  descending,
  sortedNames,
  sortedUniqNames,
  fromMidi,
  fromMidiSharps,
  freq,
  fromFreq,
  fromFreqSharps,
  chroma: chroma4,
  transpose: transpose4,
  tr,
  transposeBy,
  trBy,
  transposeFrom,
  trFrom,
  transposeFifths: transposeFifths2,
  transposeOctaves,
  trFifths,
  simplify: simplify2,
  enharmonic
};

// node_modules/@tonaljs/roman-numeral/dist/index.mjs
var NoRomanNumeral = { empty: true, name: "", chordType: "" };
var cache4 = {};
function get8(src) {
  return typeof src === "string" ? cache4[src] || (cache4[src] = parse3(src)) : typeof src === "number" ? get8(NAMES2[src] || "") : isPitch(src) ? fromPitch(src) : isNamed(src) ? get8(src.name) : NoRomanNumeral;
}
var romanNumeral = deprecate(
  "RomanNumeral.romanNumeral",
  "RomanNumeral.get",
  get8
);
function names6(major = true) {
  return (major ? NAMES2 : NAMES_MINOR).slice();
}
function fromPitch(pitch2) {
  return get8(altToAcc(pitch2.alt) + NAMES2[pitch2.step]);
}
var REGEX6 = /^(#{1,}|b{1,}|x{1,}|)(IV|I{1,3}|VI{0,2}|iv|i{1,3}|vi{0,2})([^IViv]*)$/;
function tokenize3(str) {
  return REGEX6.exec(str) || ["", "", "", ""];
}
var ROMANS = "I II III IV V VI VII";
var NAMES2 = ROMANS.split(" ");
var NAMES_MINOR = ROMANS.toLowerCase().split(" ");
function parse3(src) {
  const [name3, acc, roman, chordType2] = tokenize3(src);
  if (!roman) {
    return NoRomanNumeral;
  }
  const upperRoman = roman.toUpperCase();
  const step = NAMES2.indexOf(upperRoman);
  const alt = accToAlt(acc);
  const dir = 1;
  return {
    empty: false,
    name: name3,
    roman,
    interval: interval({ step, alt, dir }).name,
    acc,
    chordType: chordType2,
    alt,
    step,
    major: roman === upperRoman,
    oct: 0,
    dir
  };
}
var roman_numeral_default = {
  names: names6,
  get: get8,
  // deprecated
  romanNumeral
};

// node_modules/@tonaljs/key/dist/index.mjs
var Empty = Object.freeze([]);
var NoKey = {
  type: "major",
  tonic: "",
  alteration: 0,
  keySignature: ""
};
var NoKeyScale = {
  tonic: "",
  grades: Empty,
  intervals: Empty,
  scale: Empty,
  triads: Empty,
  chords: Empty,
  chordsHarmonicFunction: Empty,
  chordScales: Empty
};
var NoMajorKey = {
  ...NoKey,
  ...NoKeyScale,
  type: "major",
  minorRelative: "",
  scale: Empty,
  secondaryDominants: Empty,
  secondaryDominantsMinorRelative: Empty,
  substituteDominants: Empty,
  substituteDominantsMinorRelative: Empty
};
var NoMinorKey = {
  ...NoKey,
  type: "minor",
  relativeMajor: "",
  natural: NoKeyScale,
  harmonic: NoKeyScale,
  melodic: NoKeyScale
};
var mapScaleToType = (scale2, list, sep = "") => list.map((type, i) => `${scale2[i]}${sep}${type}`);
function keyScale(grades, triads3, chords2, harmonicFunctions, chordScales2) {
  return (tonic) => {
    const intervals2 = grades.map((gr) => get8(gr).interval || "");
    const scale2 = intervals2.map((interval2) => transpose(tonic, interval2));
    return {
      tonic,
      grades,
      intervals: intervals2,
      scale: scale2,
      triads: mapScaleToType(scale2, triads3),
      chords: mapScaleToType(scale2, chords2),
      chordsHarmonicFunction: harmonicFunctions.slice(),
      chordScales: mapScaleToType(scale2, chordScales2, " ")
    };
  };
}
var distInFifths = (from, to) => {
  const f = note(from);
  const t = note(to);
  return f.empty || t.empty ? 0 : t.coord[0] - f.coord[0];
};
var MajorScale = keyScale(
  "I II III IV V VI VII".split(" "),
  " m m   m dim".split(" "),
  "maj7 m7 m7 maj7 7 m7 m7b5".split(" "),
  "T SD T SD D T D".split(" "),
  "major,dorian,phrygian,lydian,mixolydian,minor,locrian".split(",")
);
var NaturalScale = keyScale(
  "I II bIII IV V bVI bVII".split(" "),
  "m dim  m m  ".split(" "),
  "m7 m7b5 maj7 m7 m7 maj7 7".split(" "),
  "T SD T SD D SD SD".split(" "),
  "minor,locrian,major,dorian,phrygian,lydian,mixolydian".split(",")
);
var HarmonicScale = keyScale(
  "I II bIII IV V bVI VII".split(" "),
  "m dim aug m   dim".split(" "),
  "mMaj7 m7b5 +maj7 m7 7 maj7 o7".split(" "),
  "T SD T SD D SD D".split(" "),
  "harmonic minor,locrian 6,major augmented,lydian diminished,phrygian dominant,lydian #9,ultralocrian".split(
    ","
  )
);
var MelodicScale = keyScale(
  "I II bIII IV V VI VII".split(" "),
  "m m aug   dim dim".split(" "),
  "m6 m7 +maj7 7 7 m7b5 m7b5".split(" "),
  "T SD T SD D  ".split(" "),
  "melodic minor,dorian b2,lydian augmented,lydian dominant,mixolydian b6,locrian #2,altered".split(
    ","
  )
);
function majorKey(tonic) {
  const pc = note(tonic).pc;
  if (!pc)
    return NoMajorKey;
  const keyScale2 = MajorScale(pc);
  const alteration = distInFifths("C", pc);
  const romanInTonic = (src) => {
    const r = get8(src);
    if (r.empty)
      return "";
    return transpose(tonic, r.interval) + r.chordType;
  };
  return {
    ...keyScale2,
    type: "major",
    minorRelative: transpose(pc, "-3m"),
    alteration,
    keySignature: altToAcc(alteration),
    secondaryDominants: "- VI7 VII7 I7 II7 III7 -".split(" ").map(romanInTonic),
    secondaryDominantsMinorRelative: "- IIIm7b5 IV#m7 Vm7 VIm7 VIIm7b5 -".split(" ").map(romanInTonic),
    substituteDominants: "- bIII7 IV7 bV7 bVI7 bVII7 -".split(" ").map(romanInTonic),
    substituteDominantsMinorRelative: "- IIIm7 Im7 IIbm7 VIm7 IVm7 -".split(" ").map(romanInTonic)
  };
}
function minorKey(tnc) {
  const pc = note(tnc).pc;
  if (!pc)
    return NoMinorKey;
  const alteration = distInFifths("C", pc) - 3;
  return {
    type: "minor",
    tonic: pc,
    relativeMajor: transpose(pc, "3m"),
    alteration,
    keySignature: altToAcc(alteration),
    natural: NaturalScale(pc),
    harmonic: HarmonicScale(pc),
    melodic: MelodicScale(pc)
  };
}
function majorTonicFromKeySignature(sig) {
  if (typeof sig === "number") {
    return transposeFifths2("C", sig);
  } else if (typeof sig === "string" && /^b+|#+$/.test(sig)) {
    return transposeFifths2("C", accToAlt(sig));
  }
  return null;
}
var key_default = { majorKey, majorTonicFromKeySignature, minorKey };

// node_modules/@tonaljs/mode/dist/index.mjs
var MODES = [
  [0, 2773, 0, "ionian", "", "Maj7", "major"],
  [1, 2902, 2, "dorian", "m", "m7"],
  [2, 3418, 4, "phrygian", "m", "m7"],
  [3, 2741, -1, "lydian", "", "Maj7"],
  [4, 2774, 1, "mixolydian", "", "7"],
  [5, 2906, 3, "aeolian", "m", "m7", "minor"],
  [6, 3434, 5, "locrian", "dim", "m7b5"]
];
var NoMode = {
  ...EmptyPcset,
  name: "",
  alt: 0,
  modeNum: NaN,
  triad: "",
  seventh: "",
  aliases: []
};
var modes2 = MODES.map(toMode);
var index3 = {};
modes2.forEach((mode2) => {
  index3[mode2.name] = mode2;
  mode2.aliases.forEach((alias) => {
    index3[alias] = mode2;
  });
});
function get9(name3) {
  return typeof name3 === "string" ? index3[name3.toLowerCase()] || NoMode : name3 && name3.name ? get9(name3.name) : NoMode;
}
var mode = deprecate("Mode.mode", "Mode.get", get9);
function all3() {
  return modes2.slice();
}
var entries3 = deprecate("Mode.mode", "Mode.all", all3);
function names7() {
  return modes2.map((mode2) => mode2.name);
}
function toMode(mode2) {
  const [modeNum, setNum, alt, name3, triad, seventh, alias] = mode2;
  const aliases = alias ? [alias] : [];
  const chroma5 = Number(setNum).toString(2);
  const intervals2 = get4(name3).intervals;
  return {
    empty: false,
    intervals: intervals2,
    modeNum,
    chroma: chroma5,
    normalized: chroma5,
    name: name3,
    setNum,
    alt,
    triad,
    seventh,
    aliases
  };
}
function notes3(modeName, tonic) {
  return get9(modeName).intervals.map((ivl) => transpose(tonic, ivl));
}
function chords(chords2) {
  return (modeName, tonic) => {
    const mode2 = get9(modeName);
    if (mode2.empty)
      return [];
    const triads22 = rotate2(mode2.modeNum, chords2);
    const tonics = mode2.intervals.map((i) => transpose(tonic, i));
    return triads22.map((triad, i) => tonics[i] + triad);
  };
}
var triads = chords(MODES.map((x) => x[4]));
var seventhChords = chords(MODES.map((x) => x[5]));
function distance4(destination, source) {
  const from = get9(source);
  const to = get9(destination);
  if (from.empty || to.empty)
    return "";
  return simplify(transposeFifths("1P", to.alt - from.alt));
}
function relativeTonic(destination, source, tonic) {
  return transpose(tonic, distance4(destination, source));
}
var mode_default = {
  get: get9,
  names: names7,
  all: all3,
  distance: distance4,
  relativeTonic,
  notes: notes3,
  triads,
  seventhChords,
  // deprecated
  entries: entries3,
  mode
};

// node_modules/@tonaljs/progression/dist/index.mjs
function fromRomanNumerals(tonic, chords2) {
  const romanNumerals = chords2.map(get8);
  return romanNumerals.map(
    (rn) => transpose(tonic, interval(rn)) + rn.chordType
  );
}
function toRomanNumerals(tonic, chords2) {
  return chords2.map((chord2) => {
    const [note2, chordType2] = tokenize2(chord2);
    const intervalName = distance(tonic, note2);
    const roman = get8(interval(intervalName));
    return roman.name + chordType2;
  });
}
var progression_default = { fromRomanNumerals, toRomanNumerals };

// node_modules/@tonaljs/range/dist/index.mjs
function numeric(notes4) {
  const midi3 = compact2(
    notes4.map((note2) => typeof note2 === "number" ? note2 : toMidi(note2))
  );
  if (!notes4.length || midi3.length !== notes4.length) {
    return [];
  }
  return midi3.reduce(
    (result, note2) => {
      const last = result[result.length - 1];
      return result.concat(range2(last, note2).slice(1));
    },
    [midi3[0]]
  );
}
function chromatic(notes4, options) {
  return numeric(notes4).map((midi3) => midiToNoteName(midi3, options));
}
var range_default = { numeric, chromatic };

// node_modules/@tonaljs/scale/dist/index.mjs
var NoScale = {
  empty: true,
  name: "",
  type: "",
  tonic: null,
  setNum: NaN,
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function tokenize4(name3) {
  if (typeof name3 !== "string") {
    return ["", ""];
  }
  const i = name3.indexOf(" ");
  const tonic = note(name3.substring(0, i));
  if (tonic.empty) {
    const n = note(name3);
    return n.empty ? ["", name3] : [n.name, ""];
  }
  const type = name3.substring(tonic.name.length + 1).toLowerCase();
  return [tonic.name, type.length ? type : ""];
}
var names8 = names3;
function get10(src) {
  const tokens = Array.isArray(src) ? src : tokenize4(src);
  const tonic = note(tokens[0]).name;
  const st = get4(tokens[1]);
  if (st.empty) {
    return NoScale;
  }
  const type = st.name;
  const notes4 = tonic ? st.intervals.map((i) => transpose(tonic, i)) : [];
  const name3 = tonic ? tonic + " " + type : type;
  return { ...st, name: name3, type, tonic, notes: notes4 };
}
var scale = deprecate("Scale.scale", "Scale.get", get10);
function detect2(notes4, options = {}) {
  const notesChroma = chroma2(notes4);
  const tonic = note(options.tonic ?? notes4[0] ?? "");
  const tonicChroma = tonic.chroma;
  if (tonicChroma === void 0) {
    return [];
  }
  const pitchClasses = notesChroma.split("");
  pitchClasses[tonicChroma] = "1";
  const scaleChroma = rotate2(tonicChroma, pitchClasses).join("");
  const match = all2().find((scaleType2) => scaleType2.chroma === scaleChroma);
  const results = [];
  if (match) {
    results.push(tonic.name + " " + match.name);
  }
  if (options.match === "exact") {
    return results;
  }
  extended2(scaleChroma).forEach((scaleName) => {
    results.push(tonic.name + " " + scaleName);
  });
  return results;
}
function scaleChords(name3) {
  const s = get10(name3);
  const inScale = isSubsetOf(s.chroma);
  return all().filter((chord2) => inScale(chord2.chroma)).map((chord2) => chord2.aliases[0]);
}
function extended2(name3) {
  const chroma22 = isChroma(name3) ? name3 : get10(name3).chroma;
  const isSuperset = isSupersetOf(chroma22);
  return all2().filter((scale2) => isSuperset(scale2.chroma)).map((scale2) => scale2.name);
}
function reduced2(name3) {
  const isSubset = isSubsetOf(get10(name3).chroma);
  return all2().filter((scale2) => isSubset(scale2.chroma)).map((scale2) => scale2.name);
}
function scaleNotes(notes4) {
  const pcset3 = notes4.map((n) => note(n).pc).filter((x) => x);
  const tonic = pcset3[0];
  const scale2 = sortedUniqNames(pcset3);
  return rotate2(scale2.indexOf(tonic), scale2);
}
function modeNames(name3) {
  const s = get10(name3);
  if (s.empty) {
    return [];
  }
  const tonics = s.tonic ? s.notes : s.intervals;
  return modes(s.chroma).map((chroma22, i) => {
    const modeName = get10(chroma22).name;
    return modeName ? [tonics[i], modeName] : ["", ""];
  }).filter((x) => x[0]);
}
function getNoteNameOf(scale2) {
  const names22 = Array.isArray(scale2) ? scaleNotes(scale2) : get10(scale2).notes;
  const chromas2 = names22.map((name3) => note(name3).chroma);
  return (noteOrMidi) => {
    const currNote = typeof noteOrMidi === "number" ? note(fromMidi(noteOrMidi)) : note(noteOrMidi);
    const height2 = currNote.height;
    if (height2 === void 0)
      return void 0;
    const chroma22 = height2 % 12;
    const position = chromas2.indexOf(chroma22);
    if (position === -1)
      return void 0;
    return enharmonic(currNote.name, names22[position]);
  };
}
function rangeOf(scale2) {
  const getName = getNoteNameOf(scale2);
  return (fromNote, toNote) => {
    const from = note(fromNote).height;
    const to = note(toNote).height;
    if (from === void 0 || to === void 0)
      return [];
    return range2(from, to).map(getName).filter((x) => x);
  };
}
function degrees2(scaleName) {
  const { intervals: intervals2, tonic } = get10(scaleName);
  const transpose22 = tonicIntervalsTransposer(intervals2, tonic);
  return (degree) => degree ? transpose22(degree > 0 ? degree - 1 : degree) : "";
}
function steps2(scaleName) {
  const { intervals: intervals2, tonic } = get10(scaleName);
  return tonicIntervalsTransposer(intervals2, tonic);
}
var scale_default = {
  degrees: degrees2,
  detect: detect2,
  extended: extended2,
  get: get10,
  modeNames,
  names: names8,
  rangeOf,
  reduced: reduced2,
  scaleChords,
  scaleNotes,
  steps: steps2,
  tokenize: tokenize4,
  // deprecated
  scale
};

// node_modules/@tonaljs/time-signature/dist/index.mjs
var NONE = {
  empty: true,
  name: "",
  upper: void 0,
  lower: void 0,
  type: void 0,
  additive: []
};
var NAMES3 = ["4/4", "3/4", "2/4", "2/2", "12/8", "9/8", "6/8", "3/8"];
function names9() {
  return NAMES3.slice();
}
var REGEX7 = /^(\d*\d(?:\+\d)*)\/(\d+)$/;
var CACHE = /* @__PURE__ */ new Map();
function get11(literal) {
  const stringifiedLiteral = JSON.stringify(literal);
  const cached = CACHE.get(stringifiedLiteral);
  if (cached) {
    return cached;
  }
  const ts = build(parse4(literal));
  CACHE.set(stringifiedLiteral, ts);
  return ts;
}
function parse4(literal) {
  if (typeof literal === "string") {
    const [_, up2, low] = REGEX7.exec(literal) || [];
    return parse4([up2, low]);
  }
  const [up, down] = literal;
  const denominator = +down;
  if (typeof up === "number") {
    return [up, denominator];
  }
  const list = up.split("+").map((n) => +n);
  return list.length === 1 ? [list[0], denominator] : [list, denominator];
}
var time_signature_default = { names: names9, parse: parse4, get: get11 };
var isPowerOfTwo = (x) => Math.log(x) / Math.log(2) % 1 === 0;
function build([up, down]) {
  const upper = Array.isArray(up) ? up.reduce((a, b) => a + b, 0) : up;
  const lower = down;
  if (upper === 0 || lower === 0) {
    return NONE;
  }
  const name3 = Array.isArray(up) ? `${up.join("+")}/${down}` : `${up}/${down}`;
  const additive = Array.isArray(up) ? up : [];
  const type = lower === 4 || lower === 2 ? "simple" : lower === 8 && upper % 3 === 0 ? "compound" : isPowerOfTwo(lower) ? "irregular" : "irrational";
  return {
    empty: false,
    name: name3,
    type,
    upper,
    lower,
    additive
  };
}

// node_modules/@tonaljs/voice-leading/dist/index.mjs
var topNoteDiff = (voicings, lastVoicing) => {
  if (!lastVoicing || !lastVoicing.length) {
    return voicings[0];
  }
  const topNoteMidi = (voicing) => note_default.midi(voicing[voicing.length - 1]) || 0;
  const diff = (voicing) => Math.abs(topNoteMidi(lastVoicing) - topNoteMidi(voicing));
  return voicings.sort((a, b) => diff(a) - diff(b))[0];
};
var voice_leading_default = {
  topNoteDiff
};

// node_modules/@tonaljs/voicing-dictionary/dist/index.mjs
var triads2 = {
  M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
  o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
  aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"]
};
var lefthand = {
  m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
  "7": ["3M 6M 7m 9M", "7m 9M 10M 13M"],
  "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
  "69": ["3M 5P 6A 9M"],
  m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
  "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  // b9 / b13
  "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  // b9 / b13
  o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
  "7#11": ["7m 9M 11A 13A"],
  "7#9": ["3M 7m 9A"],
  mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
  m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
};
var all4 = {
  M: ["1P 3M 5P", "3M 5P 8P", "5P 8P 10M"],
  m: ["1P 3m 5P", "3m 5P 8P", "5P 8P 10m"],
  o: ["1P 3m 5d", "3m 5d 8P", "5d 8P 10m"],
  aug: ["1P 3m 5A", "3m 5A 8P", "5A 8P 10m"],
  m7: ["3m 5P 7m 9M", "7m 9M 10m 12P"],
  "7": ["3M 6M 7m 9M", "7m 9M 10M 13M"],
  "^7": ["3M 5P 7M 9M", "7M 9M 10M 12P"],
  "69": ["3M 5P 6A 9M"],
  m7b5: ["3m 5d 7m 8P", "7m 8P 10m 12d"],
  "7b9": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  // b9 / b13
  "7b13": ["3M 6m 7m 9m", "7m 9m 10M 13m"],
  // b9 / b13
  o7: ["1P 3m 5d 6M", "5d 6M 8P 10m"],
  "7#11": ["7m 9M 11A 13A"],
  "7#9": ["3M 7m 9A"],
  mM7: ["3m 5P 7M 9M", "7M 9M 10m 12P"],
  m6: ["3m 5P 6M 9M", "6M 9M 10m 12P"]
};
var defaultDictionary = lefthand;
function lookup(symbol, dictionary3 = defaultDictionary) {
  if (dictionary3[symbol]) {
    return dictionary3[symbol];
  }
  const { aliases } = chord_default.get("C" + symbol);
  const match = Object.keys(dictionary3).find((_symbol) => aliases.includes(_symbol)) || "";
  if (match !== void 0) {
    return dictionary3[match];
  }
  return void 0;
}
var voicing_dictionary_default = {
  lookup,
  lefthand,
  triads: triads2,
  all: all4,
  defaultDictionary
};

// node_modules/@tonaljs/voicing/dist/index.mjs
var defaultRange = ["C3", "C5"];
var defaultDictionary2 = voicing_dictionary_default.all;
var defaultVoiceLeading = voice_leading_default.topNoteDiff;
function get12(chord2, range3 = defaultRange, dictionary3 = defaultDictionary2, voiceLeading = defaultVoiceLeading, lastVoicing) {
  const voicings = search(chord2, range3, dictionary3);
  if (!lastVoicing || !lastVoicing.length) {
    return voicings[0];
  } else {
    return voiceLeading(voicings, lastVoicing);
  }
}
function search(chord2, range3 = defaultRange, dictionary3 = voicing_dictionary_default.triads) {
  const [tonic, symbol] = chord_default.tokenize(chord2);
  const sets = voicing_dictionary_default.lookup(symbol, dictionary3);
  if (!sets) {
    return [];
  }
  const voicings = sets.map((intervals2) => intervals2.split(" "));
  const notesInRange = range_default.chromatic(range3);
  return voicings.reduce((voiced, voicing) => {
    const relativeIntervals = voicing.map(
      (interval2) => interval_default.subtract(interval2, voicing[0]) || ""
    );
    const bottomPitchClass = note_default.transpose(tonic, voicing[0]);
    const starts = notesInRange.filter((note2) => note_default.chroma(note2) === note_default.chroma(bottomPitchClass)).filter(
      (note2) => (note_default.midi(
        note_default.transpose(
          note2,
          relativeIntervals[relativeIntervals.length - 1]
        )
      ) || 0) <= (note_default.midi(range3[1]) || 0)
    ).map((note2) => note_default.enharmonic(note2, bottomPitchClass));
    const notes4 = starts.map(
      (start) => relativeIntervals.map((interval2) => note_default.transpose(start, interval2))
    );
    return voiced.concat(notes4);
  }, []);
}
function sequence(chords2, range3 = defaultRange, dictionary3 = defaultDictionary2, voiceLeading = defaultVoiceLeading, lastVoicing) {
  const { voicings } = chords2.reduce(
    ({ voicings: voicings2, lastVoicing: lastVoicing2 }, chord2) => {
      const voicing = get12(chord2, range3, dictionary3, voiceLeading, lastVoicing2);
      lastVoicing2 = voicing;
      voicings2.push(voicing);
      return { voicings: voicings2, lastVoicing: lastVoicing2 };
    },
    { voicings: [], lastVoicing }
  );
  return voicings;
}
var voicing_default = {
  get: get12,
  search,
  sequence
};

// node_modules/tonal/dist/index.mjs
var Tonal = dist_exports2;
var PcSet = pcset_default;
var ChordDictionary = chord_type_default;
var ScaleDictionary = scale_type_default;
export {
  abc_notation_default as AbcNotation,
  dist_exports as Array,
  chord_default as Chord,
  ChordDictionary,
  chord_type_default as ChordType,
  collection_default as Collection,
  dist_exports2 as Core,
  duration_value_default as DurationValue,
  interval_default as Interval,
  key_default as Key,
  midi_default as Midi,
  mode_default as Mode,
  note_default as Note,
  PcSet,
  pcset_default as Pcset,
  progression_default as Progression,
  range_default as Range,
  roman_numeral_default as RomanNumeral,
  scale_default as Scale,
  ScaleDictionary,
  scale_type_default as ScaleType,
  time_signature_default as TimeSignature,
  Tonal,
  voice_leading_default as VoiceLeading,
  voicing_default as Voicing,
  voicing_dictionary_default as VoicingDictionary,
  accToAlt,
  altToAcc,
  chroma,
  coordToInterval,
  coordToNote,
  coordinates,
  deprecate,
  distance,
  fillStr4 as fillStr,
  height,
  interval,
  isNamed,
  isNamedPitch,
  isPitch,
  midi,
  note,
  pitch,
  stepToLetter,
  tokenizeInterval,
  tokenizeNote,
  tonicIntervalsTransposer,
  transpose
};
//# sourceMappingURL=tonal.js.map
