{
  "version": 3,
  "sources": ["../../tone/Tone/core/util/Debug.ts", "../../tone/Tone/core/util/TypeCheck.ts"],
  "sourcesContent": ["import { isUndef } from \"./TypeCheck.js\";\nimport type { BaseContext } from \"../context/BaseContext.js\";\nimport type { Time } from \"../type/Units.js\";\n\n/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement: boolean, error: string): asserts statement {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\n/**\n * Make sure that the given value is within the range\n */\nexport function assertRange(value: number, gte: number, lte = Infinity): void {\n\tif (!(gte <= value && value <= lte)) {\n\t\tthrow new RangeError(\n\t\t\t`Value must be within [${gte}, ${lte}], got: ${value}`\n\t\t);\n\t}\n}\n\n/**\n * Warn if the context is not running.\n */\nexport function assertContextRunning(context: BaseContext): void {\n\t// add a warning if the context is not started\n\tif (!context.isOffline && context.state !== \"running\") {\n\t\twarn(\n\t\t\t'The AudioContext is \"suspended\". Invoke Tone.start() from a user action to start the audio.'\n\t\t);\n\t}\n}\n\n/**\n * If it is currently inside a scheduled callback\n */\nlet isInsideScheduledCallback = false;\nlet printedScheduledWarning = false;\n\n/**\n * Notify that the following block of code is occurring inside a Transport callback.\n */\nexport function enterScheduledCallback(insideCallback: boolean): void {\n\tisInsideScheduledCallback = insideCallback;\n}\n\n/**\n * Make sure that a time was passed into\n */\nexport function assertUsedScheduleTime(time?: Time): void {\n\tif (\n\t\tisUndef(time) &&\n\t\tisInsideScheduledCallback &&\n\t\t!printedScheduledWarning\n\t) {\n\t\tprintedScheduledWarning = true;\n\t\twarn(\n\t\t\t\"Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing\"\n\t\t);\n\t}\n}\n\n/**\n * A basic logging interface\n */\ninterface Logger {\n\tlog: (args?: any[]) => void;\n\twarn: (args?: any[]) => void;\n}\n\n/**\n * The default logger is the console\n */\nlet defaultLogger: Logger = console;\n\n/**\n * Set the logging interface\n */\nexport function setLogger(logger: Logger): void {\n\tdefaultLogger = logger;\n}\n\n/**\n * Log anything\n */\nexport function log(...args: any[]): void {\n\tdefaultLogger.log(...args);\n}\n\n/**\n * Warn anything\n */\nexport function warn(...args: any[]): void {\n\tdefaultLogger.warn(...args);\n}\n", "import { Note } from \"../type/Units.js\";\n\n/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn arg === undefined;\n}\n\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn arg !== undefined;\n}\n\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn typeof arg === \"number\";\n}\n\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (\n\t\tObject.prototype.toString.call(arg) === \"[object Object]\" &&\n\t\targ.constructor === Object\n\t);\n}\n\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn typeof arg === \"boolean\";\n}\n\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn Array.isArray(arg);\n}\n\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn typeof arg === \"string\";\n}\n\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n"],
  "mappings": ";;;;;AAAA;;;;;;;;;;;;;ACKM,SAAU,QAAQ,KAAQ;AAC/B,SAAO,QAAQ;AAChB;AAKM,SAAU,UAAa,KAAkB;AAC9C,SAAO,QAAQ;AAChB;AAKM,SAAU,WAAW,KAAQ;AAClC,SAAO,OAAO,QAAQ;AACvB;AAKM,SAAU,SAAS,KAAQ;AAChC,SAAO,OAAO,QAAQ;AACvB;AAKM,SAAU,SAAS,KAAQ;AAChC,SACC,OAAO,UAAU,SAAS,KAAK,GAAG,MAAM,qBACxC,IAAI,gBAAgB;AAEtB;AAKM,SAAU,UAAU,KAAQ;AACjC,SAAO,OAAO,QAAQ;AACvB;AAKM,SAAU,QAAQ,KAAQ;AAC/B,SAAO,MAAM,QAAQ,GAAG;AACzB;AAKM,SAAU,SAAS,KAAQ;AAChC,SAAO,OAAO,QAAQ;AACvB;AAMM,SAAU,OAAO,KAAQ;AAC9B,SAAO,SAAS,GAAG,KAAK,sCAAsC,KAAK,GAAG;AACvE;;;AD1DM,SAAU,OAAO,WAAoB,OAAa;AACvD,MAAI,CAAC,WAAW;AACf,UAAM,IAAI,MAAM,KAAK;EACtB;AACD;AAKM,SAAU,YAAY,OAAe,KAAa,MAAM,UAAQ;AACrE,MAAI,EAAE,OAAO,SAAS,SAAS,MAAM;AACpC,UAAM,IAAI,WACT,yBAAyB,GAAG,KAAK,GAAG,WAAW,KAAK,EAAE;EAExD;AACD;AAKM,SAAU,qBAAqB,SAAoB;AAExD,MAAI,CAAC,QAAQ,aAAa,QAAQ,UAAU,WAAW;AACtD,SACC,6FAA6F;EAE/F;AACD;AAKA,IAAI,4BAA4B;AAChC,IAAI,0BAA0B;AAKxB,SAAU,uBAAuB,gBAAuB;AAC7D,8BAA4B;AAC7B;AAKM,SAAU,uBAAuB,MAAW;AACjD,MACC,QAAQ,IAAI,KACZ,6BACA,CAAC,yBACA;AACD,8BAA0B;AAC1B,SACC,qJAAqJ;EAEvJ;AACD;AAaA,IAAI,gBAAwB;AAKtB,SAAU,UAAU,QAAc;AACvC,kBAAgB;AACjB;AAKM,SAAU,OAAO,MAAW;AACjC,gBAAc,IAAI,GAAG,IAAI;AAC1B;AAKM,SAAU,QAAQ,MAAW;AAClC,gBAAc,KAAK,GAAG,IAAI;AAC3B;",
  "names": []
}
